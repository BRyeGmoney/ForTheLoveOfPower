//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Gamelogic;
using Gamelogic.Grids;
using DG.Tweening;
using Vectrosity;

namespace AssemblyCSharp
{
	public enum MilitaryUnitType
	{
		Dictator,
		Infantry,
		Tank,
		Jet,
	}

	public enum MilitaryUnitAnimationIndex
	{
		Circle = 0,
		Pentagon = 1,
		Square = 2,
		Triangle = 3,
		Infantry_Idle = 4,
		Infantry_Move = 5,
		Plane_Idle = 6,
		Plane_Combat = 7,
		Plane_Death = 8,
		Plane_Move = 9,
		Tank_Idle = 10,
		Tank_Combat = 11,
		Tank_Death = 12,
		Tank_Move = 13,
		Dictator_Idle = 14,
	}

	public class MilitaryUnit : MonoBehaviour, Assets.ForTheLoveOfPower.Scripts.PlayerControlled.IObjectPoolItem
	{
        public Int16 ID { get { return id; } }
        public bool PoolObjInUse { get; set; }
        private short id;
		private PointList<PointyHexPoint> movementPath;
		private int unitAmount = 1;
		private float moveTime;
		private bool facingRight = true;

		//Properties
		public List<MilitaryUnit> Subordinates
		{
			get { return subordinates; }
		}
		private List<MilitaryUnit> subordinates;

		public MilitaryUnit commandingUnit;

		public MilitaryUnitType UnitType { get; set; }

		public Color UnitColor { get; set; }
		public float MoveTimeLimit { get; set; }
		public PointyHexPoint TilePoint { get; set; }

		public Combat combatToUpdateGame;

		public GameObject squadLeader;
		public TextMesh unitNumText;
        private GameObject damageIndic;

        public bool inCombat = false;

		//private SpriteRenderer SpriteGuy { get; set; }

		public Animator AnimationController 
		{
			get { return animator; }
		}
		private Animator animator;
        private SpriteRenderer sprite;

		public MilitaryUnit ()
		{
		}

		public void Initialize(Int16 id, Color unitColor, MilitaryUnitType uType, PointyHexPoint curPoint, int amount)
		{
            this.id = id;
			UnitColor = unitColor;
			TilePoint = curPoint;
			UnitType = uType;
            unitAmount = amount;
            sprite = gameObject.GetComponent<SpriteRenderer>();
			gameObject.GetComponentInChildren<SpriteRenderer> ().color = UnitColor;
            transform.GetChild(transform.childCount - 1).GetComponent<SpriteRenderer>().color = unitColor; //the last child should be our friendly neighborhood tactical view unit
			//SpriteGuy.color = UnitColor;
			animator = gameObject.GetComponentInChildren<Animator> ();
			movementPath = new PointList<PointyHexPoint> ();

			if (!uType.Equals (MilitaryUnitType.Dictator)) {

				squadLeader = gameObject.transform.GetChild (1).gameObject;
				unitNumText = gameObject.GetComponentInChildren<TextMesh> ();
                damageIndic = gameObject.transform.GetChild(3).gameObject;

                damageIndic.GetComponent<SpriteRenderer>().color = UnitColor;
                unitNumText.color = UnitColor;
			}

            UpdateUnitCountText();
			SetMoveTimeLimitByType ();
		}

		/// <summary>
		/// Gets the amount of units on this one tile
		/// </summary>
		/// <returns>The unit amount.</returns>
		public Int32 GetUnitAmount()
		{
			return unitAmount;
		}

		/// <summary>
		/// Pulls the next position along the movement path previously defined for the unit
		/// and manually performs the actions to visually place it there too.
		/// </summary>
		/// <param name="grid">The playing Grid</param>
		/// <param name="unitSprites">An array of pre-loaded sprites</param>
		public bool MoveNextMoveInPath(Player player)
		{
			UnitCell newCell;

			if (movementPath != null) {
				//make sure that this isn't the update cycle of a subordinate
				if (movementPath.Count > 1 && commandingUnit == null) {
					newCell = GameGridBehaviour.instance.Grid[movementPath[1]] as UnitCell;

					ChangeSpriteDirection (newCell);

					//if there's no unit on the next tile or if there is and this unit has subordinates, than its okay if its one of the subordinates
					if (!newCell.unitOnTile || (subordinates != null && subordinates.Exists (sub => sub.TilePoint.Equals (movementPath[1])))) {
						if (subordinates != null && subordinates.Count > 0) {
							bool canMove = true;
							//lets test the water with each subordinate to make sure the whole group can go
							subordinates.ForEach (subby => {
								if (canMove) { //only continue the cycle if canmove hasn't already been set to false
									PointyHexPoint newPoint = subby.TilePoint + (movementPath[1] - movementPath[0]); //just a difference thing
									canMove = subby.CheckIfNextSpotClear (newPoint, GameGridBehaviour.instance.Grid[newPoint] as UnitCell);
								}
							});

							if (canMove) { //move all subbs and the unit itself
								subordinates.ForEach (subby => {
									subby.MoveToNext (subby.movementPath[1], subby.movementPath[0]);
								});

								MoveToNext (movementPath[1], movementPath[0]);
                                return true;
							}
						} else { //if this unit has no subordinates
							MoveToNext (movementPath[1], movementPath[0]);
                            return true;
						}
					} else {
						//Stop the moving animation because we're going to be fighting now
						StartMovingAnimation (false);

						MilitaryUnit unitOnTile;

						if (newCell.Color.Equals (UnitColor)) { //if it is the same player's units
                            unitOnTile = player.playerArmy.FindUnitByPosition(movementPath[1]);

							if (unitOnTile.UnitType.Equals (UnitType)) {//if its the same as the current unit type
								unitOnTile.AddUnits (unitAmount);
								(GameGridBehaviour.instance.Grid[movementPath[0]] as UnitCell).RemoveUnit ();
								Destroy (gameObject);
							} else {
								if (subordinates != null && subordinates.Count > 0)
								{
									if (unitOnTile.commandingUnit != null) {
										unitOnTile.commandingUnit.AddSubordinates (subordinates);
									} else {
										unitOnTile.AddSubordinates (subordinates);
									}
									RemoveSubordinates (subordinates);
								}

								if (unitOnTile.commandingUnit != null)
									unitOnTile.commandingUnit.AddSubordinate (this);
								else
									unitOnTile.AddSubordinate (this);
							}
						} else { //then it must be the other players'
                            unitOnTile = GameGridBehaviour.instance.listOfPlayers[GameGridBehaviour.instance.GetIndexOfOppositePlayer(player)].playerArmy.FindUnitByPosition(movementPath[1]);

							if (unitOnTile != null) {
								combatToUpdateGame = new Combat();
								combatToUpdateGame.Setup (this, unitOnTile);
							}
						}
						movementPath.Clear ();
                        return false;
					}
				}
			}
            return false;
		}

		public bool CheckIfNextSpotClear(PointyHexPoint nextPoint, UnitCell nextCell) 
		{
			bool canMove = false;

			if (nextCell.Color.Equals (UnitColor)) { //if its one of ours, check if he's part of the group
				if (!commandingUnit.TilePoint.Equals (nextPoint) && nextCell.unitOnTile)
					canMove = commandingUnit.CheckIfSubordinateExists (nextPoint);
				else
					canMove = true;
			} else if (!nextCell.unitOnTile) {//nextCell.Color.Equals (GameGridBehaviour.baseFloorColor)) { //if its the same as the floor color
				canMove = true;
			}

			if (canMove)
				movementPath.Add (nextPoint);

			return canMove;
		}

		public void MoveToNext(PointyHexPoint newPoint, PointyHexPoint oldPoint, bool isSync = false)
		{
            UnitCell newCell = GameGridBehaviour.instance.Grid[newPoint] as UnitCell;
            UnitCell oldCell = GameGridBehaviour.instance.Grid[oldPoint] as UnitCell;

            if (!isSync)
            {
                //Check to see if any of the subordinates in the group have already been placed here, if so, lets not fuck with the tile color
                if (commandingUnit == null && subordinates == null) //if its just a regular unit
                    oldCell.RemoveUnit(); //(GameGridBehaviour.instance.Grid[movementPath[0]] as UnitCell)
                else if (subordinates != null && !subordinates.Any(sub => sub.TilePoint == movementPath[0])) //if we are the leader and we want to make sure a sub isn't in this spot
                    oldCell.RemoveUnit();
                else if (commandingUnit != null && !commandingUnit.subordinates.Any(sub => sub.TilePoint == movementPath[0] && sub != this)) //if we're a sub and want to see if there are any other subs out there in this spot
                    oldCell.RemoveUnit();
            }
            else
                oldCell.RemoveUnit();

            if (movementPath.Count > 0)
			    movementPath.RemoveAt (0);

            SetNewUnitPosition(newCell, newPoint);
			
			if (!isSync && movementPath.Count <= 1)
				StartMovingAnimation(false);

            if (!isSync)
                CheckWhatsOnTile(newCell);
		}

        public void SetNewUnitPosition(UnitCell newCell, PointyHexPoint newPoint)
        {
            newCell.AddUnitToTile(this);
            gameObject.transform.position = newCell.transform.position;
            TilePoint = newPoint;
        }

        private void CheckWhatsOnTile(UnitCell tileUnderUnit)
        {
            if (tileUnderUnit.structureOnTile != null) //is there a building here?
            {
                if (tileUnderUnit.structureOnTile.StructColor == 
                    GameGridBehaviour.instance.listOfPlayers[GameGridBehaviour.localPlayer].PlayerColor && 
                    tileUnderUnit.structureOnTile.StructureType.Equals(StructureUnitType.Settlement) && 
                    UnitType.Equals(MilitaryUnitType.Dictator)) //is it one of ours and are we a dictator?
                {

                } else
                {
                    if (tileUnderUnit.structureOnTile.StructureType.Equals(StructureUnitType.Settlement))
                    {
                        (tileUnderUnit.structureOnTile as Settlement)
                            .BeginSettlementCapture(GameGridBehaviour.instance.listOfPlayers[GameGridBehaviour.localPlayer].PlayerColor);
                    }
                }
            }
        }

		public void ChangeSpriteDirection(UnitCell nextPoint)
		{
			if (animator != null) {
				if (nextPoint.transform.position.x < gameObject.transform.position.x && facingRight) {
                    animator.transform.Rotate (0, 180, 0);
					facingRight = false;
				} else if (nextPoint.transform.position.x > gameObject.transform.position.x && !facingRight) {
                    animator.transform.Rotate (0, 180, 0);
					facingRight = true;
				}
			}
		}

		void StartMovingAnimation(bool move) {
			if (animator != null)
				animator.SetBool ("isMoving", move);
		}

		public void StartCombatAnimation() {
			if (animator != null)
				animator.SetTrigger ("inCombat");
		}

		public void StopCombatAnimation() {
			if (animator != null)
				animator.SetTrigger ("wonCombat");
		}

		public void StartDeathAnimation() {
			if (animator != null)
				animator.SetTrigger ("isKilled");
		}

		public void SetMovementPath(PointList<PointyHexPoint> newPath)
		{
			movementPath.AddRange(newPath);


			if (subordinates != null) {
				subordinates.ForEach (sub => {
					sub.movementPath.Clear ();
					sub.movementPath.Add (sub.TilePoint);

					if (movementPath.Count > 1)
						sub.StartMovingAnimation (true);
				});
			}
			if (movementPath.Count > 1)
				StartMovingAnimation (true);
		}

		public void ClearMovementPath()
		{
			movementPath.Clear ();
		}

		public void AddUnits(int amountToAdd)
		{
			unitAmount += amountToAdd;

            UpdateUnitCountText();
		}

		public void RemoveUnits(int amountToRemove)
		{
			unitAmount -= amountToRemove;
            

            UpdateUnitCountText();
        }

        public void DamageUnit()
        {
            RemoveUnits(1);
            if (unitAmount > 0)
                StartCoroutine(PlayHitAnimation());
        }

        public void ShootAnimation(Vector3 enemyPosition)
        {
            VectorLine shot = VectorLine.SetLine3D(UnitColor, 0.6f, gameObject.transform.position, gameObject.transform.position);
            shot.color = UnitColor;
            shot.lineWidth = GetBulletSize();

            DOTween.To(() => shot.points3[0], s => shot.points3[0] = s, enemyPosition, 0.2f);
            DOTween.To(() => shot.points3[1], s => shot.points3[1] = s, enemyPosition, 0.3f);
        }

        private IEnumerator PlayHitAnimation()
        {
            int x = 0;
            damageIndic.SetActive(true);

            while (x < 4)
            {
                damageIndic.transform.localScale = Vector3.zero;
                damageIndic.transform.localPosition = new Vector3(UnityEngine.Random.Range(-64, 64), UnityEngine.Random.Range(-64, 64), 0);
                damageIndic.transform.DOScale(1, 0.2f);
                x++;
                yield return new WaitForSeconds(0.2f);
            }

            DOTween.Punch(() => gameObject.transform.position, s => gameObject.transform.position = s, new Vector3(UnityEngine.Random.Range(-32f, 32f), UnityEngine.Random.Range(-32f, 32f), 0), 1f, 10, 1);

            damageIndic.SetActive(false);

            yield return null;
        }

        private void UpdateUnitCountText()
        {
            if (unitNumText != null)
            {
                if (unitAmount > 1)
                    unitNumText.text = unitAmount.ToString();
                else
                    unitNumText.text = string.Empty;
            }
        }

		public bool CheckIfSubordinateExists(PointyHexPoint pointToCheck) 
		{
			if (subordinates != null) {
				if (subordinates.Exists (unit => unit.TilePoint.Equals (pointToCheck)))
					return true;
				else
					return false;
			}

			return false;
		}

		public void AddSubordinate(MilitaryUnit unitToCommand)
		{
			if (subordinates == null)
				subordinates = new List<MilitaryUnit> ();

			squadLeader.SetActive (true);

			subordinates.Add (unitToCommand);
			unitToCommand.commandingUnit = this;
		}

		public void AddSubordinates(List<MilitaryUnit> unitsToCommand)
		{
			if (subordinates == null)
				subordinates = new List<MilitaryUnit> ();

			squadLeader.SetActive (true);

			unitsToCommand.ForEach (sub => sub.commandingUnit = this);

			subordinates.AddRange (unitsToCommand);
		}

		public void RemoveSubordinate(MilitaryUnit unitToRemove)
		{
			subordinates.Remove (unitToRemove);

			if (subordinates.Count < 1)
				squadLeader.SetActive (false);
		}


		public void RemoveSubordinates(List<MilitaryUnit> unitsToRemove)
		{
			unitsToRemove.ForEach (unit => {
				subordinates.Remove (unit);
			});

			if (subordinates.Count < 1)
				squadLeader.SetActive (false);
		}

		public void UpdateUnit(IGrid<PointyHexPoint> grid, Player player)
		{
			if (unitAmount <= 0) {
                player.playerArmy.RemoveFromUnits(this);
			} else { //if he's still alive then lets update him
				if (moveTime > MoveTimeLimit) {
					if (MoveNextMoveInPath (player))
                        player.playerArmy.dirtyUnits.Add(new ArmyUpdate() { mpCommand = (short)MpMilitaryCommands.MoveUnit, Unit = this });

                    moveTime = 0f;
				}

				moveTime += Time.deltaTime;
			}
		}

		private void SetMoveTimeLimitByType() {
			if (UnitType.Equals (MilitaryUnitType.Dictator))
				MoveTimeLimit = 2f;
			else if (UnitType.Equals (MilitaryUnitType.Infantry))
				MoveTimeLimit = 1.75f;
			else if (UnitType.Equals (MilitaryUnitType.Tank))
				MoveTimeLimit = 1.25f;
			else
				MoveTimeLimit = 1f;
		}

		public float GetUnitAnimationTime()
		{
			if (UnitType.Equals (MilitaryUnitType.Infantry))
				return 0.7272727f;
			else if (UnitType.Equals (MilitaryUnitType.Tank))
				return 0.625f;
			else if (UnitType.Equals (MilitaryUnitType.Jet))
				return 0.7857143f;
			else
				return 0.5f;
		}

        private float GetBulletSize()
        {
            if (UnitType == MilitaryUnitType.Infantry)
                return 7f;
            else if (UnitType == MilitaryUnitType.Tank)
                return 10f;
            else
                return 8f;
        }
    }

    public class Army : MonoBehaviour
    {
        public List<MilitaryUnit> army;
        public List<ArmyUpdate> dirtyUnits;

        short NextUnitID;

        public Army()
        {
            army = new List<MilitaryUnit>();
            dirtyUnits = new List<ArmyUpdate>();
        }

        public int GetUnitCount()
        {
            return army.Count;
        }

        public MilitaryUnit FindUnitByID(short id)
        {
            return army.Find(unit => unit.ID == id);
        }

        public MilitaryUnit FindUnitByPosition(PointyHexPoint positionToSearch)
        {
            return army.Find(mU => mU.TilePoint.Equals(positionToSearch));
        }

        public void AddToUnits(MilitaryUnit unit)
        {
            army.Add(unit);
            dirtyUnits.Add(new ArmyUpdate() { mpCommand = (short)MpMilitaryCommands.AddUnit, Unit = unit });
        }

        public bool RemoveFromUnits(MilitaryUnit unit)
        {
            army.Remove(unit);
            dirtyUnits.Add(new ArmyUpdate() { mpCommand = (short)MpMilitaryCommands.RemoveUnit, Unit = unit });

            return true;
        }

        public void RemoveFromUnits(MilitaryUnit[] units)
        {
            units.All(unit => RemoveFromUnits(unit));
        }

        public IEnumerable<MilitaryUnit> UnitsUnderAttack()
        {
            return army.Where(unit => unit.inCombat);
        }

        public void UpdateUnits(Player player)
        {
            army.ForEach(unit => {

                if (unit != null)
                {
                    unit.UpdateUnit(GameGridBehaviour.instance.Grid, player);

                    if (unit.GetUnitAmount() < 1)
                    {
                        StartCoroutine(DestroyUnitAfterAnimation(unit, player));
                    }
                    else if (unit.combatToUpdateGame != null)
                    {
                        GameGridBehaviour.instance.listofCurrentCombats.Add(unit.combatToUpdateGame);
                        unit.combatToUpdateGame = null;
                    }
                }
                else
                    army.Remove(unit);
            });
        }

        public IEnumerator DestroyUnitAfterAnimation(MilitaryUnit unit, Player player)
        {
            Debug.Log("destroying reference to unit");
            army.Remove(unit);
            (GameGridBehaviour.instance.Grid[unit.TilePoint] as UnitCell).RemoveUnit();

            yield return new WaitForSeconds(unit.GetUnitAnimationTime());

            if (unit.UnitType.Equals(MilitaryUnitType.Dictator))
                player.dictAlive = false;

            ObjectPool.instance.DestroyOldUnit(unit);//Destroy(unit.gameObject);
        }

        public void TryToBuildDictator(UnitCell clickedCell, PointyHexPoint clickedPoint, Player player)
        {
            //if the player has no units, then this is how we let them place the dictator
            if (GetUnitCount() <= 0)
                CreateNewUnit(clickedPoint, MilitaryUnitType.Dictator, player);
        }

        public void TryToBuildUnit(UnitCell clickedCell, PointyHexPoint clickedPoint, Player player)
        {
            //if it is of the military variety
            if (clickedCell.structureOnTile.tag.Equals("Military") && clickedCell.structureOnTile.currentState == StructureState.Owned)
            {
                //if there's already a unit on this tile, we should just add to it
                if (clickedCell.unitOnTile)
                {
                    MilitaryUnit unitOnTile = army.Find(unit => unit.TilePoint.Equals(clickedPoint));

                    if (unitOnTile != null)
                        unitOnTile.AddUnits(1);
                }
                else if (clickedCell.structureOnTile.StructureType.Equals(StructureUnitType.Barracks))
                    CreateNewUnit(clickedPoint, MilitaryUnitType.Infantry, player);
                else if (clickedCell.structureOnTile.StructureType.Equals(StructureUnitType.TankDepot))
                    CreateNewUnit(clickedPoint, MilitaryUnitType.Tank, player);
                else
                    CreateNewUnit(clickedPoint, MilitaryUnitType.Jet, player);
            }
        }

        public void CreateNewUnit(PointyHexPoint buildPoint, MilitaryUnitType milType, Player player)
        {
            CreateNewUnit(buildPoint, milType, 1, player);
        }

        public void CreateNewUnit(PointyHexPoint buildPoint, MilitaryUnitType milType, int amountOf, Player player, short unitId = -1)
        {
            UnitCell gridCell = GameGridBehaviour.instance.Grid[buildPoint] as UnitCell;

            MilitaryUnit newUnit;
            if (unitId < 0)
                newUnit = ObjectPool.instance.PullNewUnit(milType, gridCell.transform.position); //(Instantiate(GameGridBehaviour.instance.unitTypes[(int)milType], gridCell.transform.position, Quaternion.identity) as GameObject).GetComponent<MilitaryUnit>();
            else
                newUnit = ObjectPool.instance.PullNewUnit(milType, gridCell.transform.position, unitId);

            newUnit.Initialize(GetNextUnitID(), player.PlayerColor, milType, buildPoint, 1);
            AddToUnits(newUnit);
            gridCell.AddUnitToTile(newUnit);
            /*GameGridBehaviour.instance.CreateNewMilitaryUnit(this,
                (int)milType,
                GameGridBehaviour.instance.Grid[buildPoint] as UnitCell,
                buildPoint);*/
        }

        public Int16 GetNextUnitID()
        {
            return NextUnitID++;
        }
    }

    public class ArmyUpdate
    {
        public Int16 mpCommand { get; set; }
        public MilitaryUnit Unit { get; set; }
    }

    public enum MpMilitaryCommands
    {
        AddUnit = 500,
        RemoveUnit = 501,
        MoveUnit = 502,
    }
}

